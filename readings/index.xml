<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Readings on Luke Olney</title>
    <link>https://lolney.github.io/readings/</link>
    <description>Recent content in Readings on Luke Olney</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 04 Mar 2018 02:20:05 -0800</lastBuildDate>
    
	<atom:link href="https://lolney.github.io/readings/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Making the Touch Bar finally useful</title>
      <link>https://lolney.github.io/readings/mbp-touchbar-customization-showcase/</link>
      <pubDate>Thu, 05 Apr 2018 01:16:20 -0700</pubDate>
      
      <guid>https://lolney.github.io/readings/mbp-touchbar-customization-showcase/</guid>
      <description>This is a pretty neat showcase about customizing the touchbar on the latest Macbook Pros. It&amp;rsquo;s appropriate that it begins with a picture of the author&amp;rsquo;s super customized Linux desktop from 2007, because the last time I thought about this sort of thing was while reading &amp;ldquo;show off your desktop&amp;rdquo; threads in Macrumors threads c. 2007-2008. I wasn&amp;rsquo;t aware that Applescript was so capable &amp;ndash; it has super convient APIs for apps like Spotify and concise JSON fetching and parsing.</description>
    </item>
    
    <item>
      <title>World Models</title>
      <link>https://lolney.github.io/readings/world-models/</link>
      <pubDate>Wed, 04 Apr 2018 02:01:00 -0700</pubDate>
      
      <guid>https://lolney.github.io/readings/world-models/</guid>
      <description>This is an interesting &amp;ndash; paraphrasing from the article &amp;ndash; &amp;ldquo;distillation of reinforcement learning research from the past two decades,&amp;rdquo; approaching from a cognitive science perspective. It considers the paradigm of training a large (many parameter) model to build a representation of the environment and its future, then training a smaller controller model, which outputs actions, from that representation. The future model, they argue, is similar to the way that humans make decisions &amp;ndash; by considering how their actions will affect the future.</description>
    </item>
    
    <item>
      <title>What color is your function?</title>
      <link>https://lolney.github.io/readings/function-color/</link>
      <pubDate>Tue, 03 Apr 2018 01:31:00 -0700</pubDate>
      
      <guid>https://lolney.github.io/readings/function-color/</guid>
      <description>This blog post imagines a programming language with &amp;ldquo;colored functions&amp;rdquo; &amp;ndash; function are either blue or red, and differently-colored functions cannot be passed to or called from each other, plus have different calling conventions &amp;ndash; as an analogy for async functions. The point, I suppose, is to show the unwieldiness of interactions between async and code. After trying to navigate [futures in Rust for a while](), I can see the point.</description>
    </item>
    
    <item>
      <title>Iaia</title>
      <link>https://lolney.github.io/readings/iaia/</link>
      <pubDate>Sun, 01 Apr 2018 14:40:09 -0700</pubDate>
      
      <guid>https://lolney.github.io/readings/iaia/</guid>
      <description>A lot of PL research is about better patterns of programming, covering new ways of abstracting patterns that you encounter in a real codebase. Two of the most beloved courses at NU, Prof. Robby Findler&amp;rsquo;s courses on Compilers and Programming Languages, are built on that principle: they are basically programming seminars, with very little formal introduction to the concepts they cover - instead letting them reveal themselves through the assignments. Indeed, a compiler isn&amp;rsquo;t built the way it is because the concept of a &amp;lsquo;compiler&amp;rsquo; is written in natural law - it&amp;rsquo;s a revealed way of handling the complexity that comes with all the forms the grammar of the language can express itself.</description>
    </item>
    
    <item>
      <title>Tail Calls in Rust</title>
      <link>https://lolney.github.io/readings/tail-calls/</link>
      <pubDate>Sun, 01 Apr 2018 14:39:40 -0700</pubDate>
      
      <guid>https://lolney.github.io/readings/tail-calls/</guid>
      <description>The main transformation to enable tail calls is to replace the function call f with a goto, calling destructors on local variables, then replacing the original arguments of the current function with the arguments of f. The normal borrow semantics for the return should therefore apply.
A tail call is only valid if there is nothing to be done in the caller after the call. This implementation checks this by first creating a node for become in HIR, then later, in MIR, checks that the &amp;ldquo;basic block being branched into&amp;rdquo; either &amp;ldquo;has length zero&amp;rdquo; or &amp;ldquo;terminates with a return.</description>
    </item>
    
    <item>
      <title>IPFS (Interplanetary File System) Proposal Paper</title>
      <link>https://lolney.github.io/readings/ipfs/</link>
      <pubDate>Tue, 27 Mar 2018 14:40:00 -0700</pubDate>
      
      <guid>https://lolney.github.io/readings/ipfs/</guid>
      <description>IPFS is a distributed file system. It combines ideas from Kademlia, Bittorrent, Git,and Self-Certified Filesystems, taking respectively 1) routing and node identity, 2) block exchange, 3) Merkle tree-based verification and versioning, and 4) self-certification - addresses derived from public keys.
The result is something like a DHT that stores Git objects and uses the Bittorrent protocol for distribution. The certificate system, which does not rely on a trusted 3rd party to map addresses to public keys, is another major feature, allowing public-key encryption and ensuring that a malicious node can&amp;rsquo;t impersonate a node that has already established trust.</description>
    </item>
    
    <item>
      <title>DNS Rebinding</title>
      <link>https://lolney.github.io/readings/dns-rebinding/</link>
      <pubDate>Fri, 23 Mar 2018 14:40:23 -0700</pubDate>
      
      <guid>https://lolney.github.io/readings/dns-rebinding/</guid>
      <description>These attacks involve using DNS rebinding to allow a website to send requests to HTTP servers on a user&amp;rsquo;s machine. The targets include RPC servers included with uTorrent and with Blizzard Updater.
DNS rebinding is meant to get around the same origin policy. The scheme is: setup a domain and a DNS server with a short TTL. Once that&amp;rsquo;s expired, serve a script that makes a request to the origin domain - but when the browser makes a DNS request, respond with localhost instead.</description>
    </item>
    
    <item>
      <title>Async in Rust</title>
      <link>https://lolney.github.io/readings/async-in-rust/</link>
      <pubDate>Thu, 22 Mar 2018 14:40:36 -0700</pubDate>
      
      <guid>https://lolney.github.io/readings/async-in-rust/</guid>
      <description>Asynchronous programming usually aim to make it easier to reason about asynchronous operations. For example, by avoiding explicitly working with threads &amp;ndash; the asynchronous library handles that itself&amp;ndash; you can avoid complexity while avoiding the overhead of unnecessary thread spawning. In Rust, these constructs are &amp;lsquo;tasks.&amp;rsquo; When you run a task, instead of blocking, it returns control to the executor thread. The task runs until it would block, then returns Async::Pending.</description>
    </item>
    
    <item>
      <title>Bind Before Connect</title>
      <link>https://lolney.github.io/readings/bind-before-connect/</link>
      <pubDate>Tue, 20 Mar 2018 14:40:49 -0700</pubDate>
      
      <guid>https://lolney.github.io/readings/bind-before-connect/</guid>
      <description>If you create a socket and call connect(dst, port) on it, or first call bind(src, port) with port 0, the kernel will allocate from the pool of up to 64k available ports. However, with with SO_REUSEPORT, you can also share ports to create an effectively unlimited number of connections - as long as the destination address is different for each connection sharing the same port. To have multiple connections to the same IP/Port pair, you can use different source IP addresses instead.</description>
    </item>
    
    <item>
      <title>Pitfalls of OO Design</title>
      <link>https://lolney.github.io/readings/oo-design/</link>
      <pubDate>Thu, 15 Mar 2018 14:40:58 -0700</pubDate>
      
      <guid>https://lolney.github.io/readings/oo-design/</guid>
      <description>An overview for the reasons that more recent languages (Rust, Go) have avoided the full-on object-orientedness of Java, C#, et. al. Traits and interfaces allow for polymorphism while avoiding the problems of inheritance - they&amp;rsquo;re not hierarchical, so they avoid issues like the diamond problem that result when implementing new objects that don&amp;rsquo;t fit easily into the existing hierarchy. Non-hierarchical structs also avoid the bloat of carrying around unnecessary parent fields.</description>
    </item>
    
  </channel>
</rss>