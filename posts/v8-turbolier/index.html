<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"> <meta name="generator" content="Hugo 0.37" /> 
<title>Using Turbolizer to inspect the V8 JIT compiler - Luke Olney</title>
<meta property="og:title" content="Using Turbolizer to inspect the V8 JIT compiler - Luke Olney">       

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>





<script async src="https://www.googletagmanager.com/gtag/js?id=UA-116576963-1"></script>
<script>
	window.dataLayer = window.dataLayer || [];
	function gtag() { dataLayer.push(arguments); }
	gtag('js', new Date());

	gtag('config', 'UA-116576963-1');
</script>


<link rel="stylesheet" href="https://lukeolney.me/css/main.css" media="all">
<link rel="stylesheet" href="https://lukeolney.me/css/fonts.css">
  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="https://lukeolney.me/" class="nav-logo">
    <img src="https://lukeolney.me/images/logo.png" 
         width="50" 
         height="50" 
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="/projects/">Projects</a></li>
    
    <li><a href="/readings/">Readings</a></li>
    
    <li><a href="/tags/">Tags</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">
  <article class="article">
    
    <h1 class="article-title">Using Turbolizer to inspect the V8 JIT compiler</h1>
    

    
    <span class="article-date">2019-10-13</span>
    



    <div class="article-content">
      

<p>Browser engines have sophisticated JIT compilers optimizing your JS code, but it&rsquo;s usually a completely opaque process. You normally get no information about what what code is getting JIT compiled, how loops might be unrolled, memory accesses optimized, etc. V8 in particular is pretty good at hiding that, <a href="https://docs.google.com/document/d/1zl0IA7dbPffvPPkaCmLVPttq4BYIfAe2Qy8sapkYgRE/edit#heading=h.x1cv1fi5g42q">even when using the debugger or profiling</a>.</p>

<p>But V8 does give you the ability to inspect the JIT process, using the <code>--trace—turbo</code> flag and a tool called <em>Turbolizer</em>. You can use the command line to generate a trace, then use <a href="https://github.com/v8/v8/tree/master/tools/turbolizer">the visualization tool provided in the V8 repo</a> to view it:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">node --trace-turbo &lt;( <span style="color:#24909d">echo</span> <span style="color:#ed9d13">&#34;for(var i=0; i&lt; 10000000; i++) { i*2; }&#34;</span>)</code></pre></div>
<p>Some notes: The <code>--trace-turbo</code> option refers to using the <a href="https://v8.dev/docs/turbofan">TurboFan</a> optimizing compiler. Using a small number of iterations (like 100) won&rsquo;t produce any optimized code. Upping that to 10000000 will.</p>

<p>The data generated consists of <em>phases</em> of the JIT compilation process, divided into <em>nodes</em> of the <a href="https://darksi.de/d.sea-of-nodes/">sea-of-nodes</a> graph generated by the compiler:</p>

<p><img src="https://i.imgur.com/2pFJgAW.png" alt="generated data" /></p>

<p>Turbolizer visualizes this data, showing how the control flow of the generated code at various points in the compilation process. From the first generated bytecode, where you can see the original branch (i&lt;10000000):</p>

<p><img src="https://i.imgur.com/YXF3VlO.png" alt="first step" /></p>

<p>To the last step:</p>

<p><img src="https://i.imgur.com/BJYnELl.png" alt="last step" /></p>

<p>Notice that most of the additions here are <code>DeoptimizeIf</code> blocks or additional branches. Deoptimizing blocks will bail out to deoptimized code if certain checks are violated (here, overflow checks). <a href="https://users.soe.ucsc.edu/~renau/docs/iiswc16.pdf">https://users.soe.ucsc.edu/~renau/docs/iiswc16.pdf</a></p>

<p>Some other explanations: a &ldquo;merge&rdquo; is the opposite of a branch, a control flow mechanism that makes sure that operations aren&rsquo;t reordered. A V8 developer goes into more depth on these concepts here: <a href="https://stackoverflow.com/questions/57463700/meaning-of-merge-phi-effectphi-and-dead-in-v8-terminology">https://stackoverflow.com/questions/57463700/meaning-of-merge-phi-effectphi-and-dead-in-v8-terminology</a></p>

<p>The actual optimizations steps done are the following: loop peeling, early optimization, store-store elimination, control flow optimization, memory optimization, and late optimization. In this example, the only steps that actually produce changes are loop peeling and late optimization, eliminating a <code>DeoptimizeUnless</code>.</p>

<p>The <code>DeoptimizeUnless</code> checked that the result is not an SMI, or 32-bit (small) integer. It&rsquo;s not clear what may have produced that optimization, though you can see that the largest number involved in the above code is 10,000,000, and the largest computed is 2x that (both under the 32 bit limit).</p>

<p><img src="https://i.imgur.com/dERB5SC.png" alt="eliminated step" /></p>

<p>Also of note is the turbo-&lt;*&gt;.cfg file, which contains several blocks of the intermediate representation code, then the final assembly code. The blocks represent nodes in the control flow graph, a coarser representation of the program than the sea-of-nodes graph — see this helpful link again: <a href="https://darksi.de/d.sea-of-nodes/">https://darksi.de/d.sea-of-nodes/</a>.</p>

<p><a href="https://gist.github.com/lolney/6ec235c9dd911c94c7d8b1849bbb6244">Here&rsquo;s the full file generated from this example</a>. It&rsquo;s possible to pick out some elements from the original JS code, like the constant being defined as n75:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a61717;background-color:#e3d2d2">0</span> <span style="color:#a61717;background-color:#e3d2d2">1</span> <span style="color:#447fcf">n75</span> <span style="color:#40ffff">Int32Constant</span>[<span style="color:#3677a9">10000000</span>]   <span style="color:#40ffff">pos</span>:<span style="color:#3677a9">76</span> <span style="color:#a61717;background-color:#e3d2d2">&lt;|@</span></code></pre></div>
<p>Then the branch after comparing the iteration counter (i &lt; 1000000) to n75:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a61717;background-color:#e3d2d2">0</span> <span style="color:#a61717;background-color:#e3d2d2">1</span> <span style="color:#447fcf">n30</span> <span style="color:#40ffff">Int32LessThan</span>   <span style="color:#40ffff">n21</span> <span style="color:#40ffff">n75</span>  <span style="color:#40ffff">type</span>:<span style="color:#40ffff">Boolean</span> <span style="color:#40ffff">pos</span>:<span style="color:#3677a9">76</span> <span style="color:#a61717;background-color:#e3d2d2">&lt;|@</span>
<span style="color:#a61717;background-color:#e3d2d2">0</span> <span style="color:#a61717;background-color:#e3d2d2">0</span> <span style="color:#447fcf">n31</span> <span style="color:#40ffff">Branch</span>[<span style="color:#40ffff">None</span><span style="color:#a61717;background-color:#e3d2d2">|</span><span style="color:#40ffff">NoSafetyCheck</span>]   <span style="color:#40ffff">n30</span> <span style="color:#40ffff">Ctrl</span>: <span style="color:#40ffff">n18</span> -<span style="color:#a61717;background-color:#e3d2d2">&gt;</span> <span style="color:#40ffff">B7</span> <span style="color:#40ffff">B11</span>  <span style="color:#a61717;background-color:#e3d2d2">&lt;|@</span></code></pre></div>
<p>Some other interesting things to note: block 1 contains a safety check on the OSR (on stack replacement) values, <a href="https://stackoverflow.com/a/9105846">referring to the way the compiler switches between optimized and deoptimized versions of code</a>. It&rsquo;s a check that a certain OSRValue - the eighth index of this array - is a small integer, though it&rsquo;s not clear to me what this number represents or why that would not be the case.</p>

<p>This presentation is helpful for understanding the what the various oppcodes represent, how these change over the stages of compiler, how the sea-of-nodes graph is formed, and how the control flow graph is formed: <a href="https://docs.google.com/presentation/d/1Z9iIHojKDrXvZ27gRX51UxHD-bKf1QcPzSijntpMJBM/edit#slide=id.g19134d40cb_0_29">https://docs.google.com/presentation/d/1Z9iIHojKDrXvZ27gRX51UxHD-bKf1QcPzSijntpMJBM/edit#slide=id.g19134d40cb_0_29</a></p>

<h4 id="conclusions">Conclusions</h4>

<p>While this is a great tool for understanding how Turbo works, it&rsquo;s pretty impractical for analyzing performance. The IR, hard enough to decipher for even a small example like this, is likely a lot worse for more complicated code. It&rsquo;s hard to imagine a situation where reading the JITed code would help you where the Chrome profiler would not, unless you&rsquo;re developing V8 itself or trying to find bugs in it.</p>

<p>It also doesn&rsquo;t give any insight into when the optimized code is generated or how the compilation interacts with the rest of V8. While there&rsquo;s a script for using the tool with <code>perf</code> to trace the performance of the JITed code, this option requires first building V8 from source, then, on my system, <a href="https://askubuntu.com/a/606455">cloning the Linux kernel and building perf from source</a>, so I didn&rsquo;t try this. But for those willing to put in the work, that seems like it could yield better insights about how the compiler affects runtime performance.</p>

    </div>

    <ul class="article-taxonomy">
     
</ul>
  </article>

</main>

<footer class="footer">
  <ul class="footer-links">
    <li>
      <a href="https://github.com/lolney">
        <i class="fa fa-github"></i> Github</a>
    </li>
  </ul>
</footer>

</div>

</body>

</html>