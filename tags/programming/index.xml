<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on Luke Olney</title>
    <link>https://lolney.github.io/tags/programming/</link>
    <description>Recent content in Programming on Luke Olney</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 03 Apr 2018 01:31:00 -0700</lastBuildDate>
    
	<atom:link href="https://lolney.github.io/tags/programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>What color is your function?</title>
      <link>https://lolney.github.io/readings/function-color/</link>
      <pubDate>Tue, 03 Apr 2018 01:31:00 -0700</pubDate>
      
      <guid>https://lolney.github.io/readings/function-color/</guid>
      <description>This blog post imagines a programming language with &amp;ldquo;colored functions&amp;rdquo; &amp;ndash; function are either blue or red, and differently-colored functions cannot be passed to or called from each other, plus have different calling conventions &amp;ndash; as an analogy for async functions. The point, I suppose, is to show the unwieldiness of interactions between async and code. After trying to navigate [futures in Rust for a while](), I can see the point.</description>
    </item>
    
    <item>
      <title>Async in Rust</title>
      <link>https://lolney.github.io/readings/async-in-rust/</link>
      <pubDate>Thu, 22 Mar 2018 14:40:36 -0700</pubDate>
      
      <guid>https://lolney.github.io/readings/async-in-rust/</guid>
      <description>Asynchronous programming usually aim to make it easier to reason about asynchronous operations. For example, by avoiding explicitly working with threads &amp;ndash; the asynchronous library handles that itself&amp;ndash; you can avoid complexity while avoiding the overhead of unnecessary thread spawning. In Rust, these constructs are &amp;lsquo;tasks.&amp;rsquo; When you run a task, instead of blocking, it returns control to the executor thread. The task runs until it would block, then returns Async::Pending.</description>
    </item>
    
    <item>
      <title>Bind Before Connect</title>
      <link>https://lolney.github.io/readings/bind-before-connect/</link>
      <pubDate>Tue, 20 Mar 2018 14:40:49 -0700</pubDate>
      
      <guid>https://lolney.github.io/readings/bind-before-connect/</guid>
      <description>If you create a socket and call connect(dst, port) on it, or first call bind(src, port) with port 0, the kernel will allocate from the pool of up to 64k available ports. However, with with SO_REUSEPORT, you can also share ports to create an effectively unlimited number of connections - as long as the destination address is different for each connection sharing the same port. To have multiple connections to the same IP/Port pair, you can use different source IP addresses instead.</description>
    </item>
    
  </channel>
</rss>