<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust Internals on Luke Olney</title>
    <link>https://lolney.github.io/tags/rust-internals/</link>
    <description>Recent content in Rust Internals on Luke Olney</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 01 Apr 2018 14:39:40 -0700</lastBuildDate>
    
	<atom:link href="https://lolney.github.io/tags/rust-internals/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Tail Calls in Rust</title>
      <link>https://lolney.github.io/readings/tail-calls/</link>
      <pubDate>Sun, 01 Apr 2018 14:39:40 -0700</pubDate>
      
      <guid>https://lolney.github.io/readings/tail-calls/</guid>
      <description>The main transformation to enable tail calls is to replace the function call f with a goto, calling destructors on local variables, then replacing the original arguments of the current function with the arguments of f. The normal borrow semantics for the return should therefore apply.
A tail call is only valid if there is nothing to be done in the caller after the call. This implementation checks this by first creating a node for become in HIR, then later, in MIR, checks that the &amp;ldquo;basic block being branched into&amp;rdquo; either &amp;ldquo;has length zero&amp;rdquo; or &amp;ldquo;terminates with a return.</description>
    </item>
    
  </channel>
</rss>